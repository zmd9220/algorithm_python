# 사다리
# 먼저 맨 윗줄이 1일 경우 시작함(0일 경우 사다리가 아니므로) 이걸 전체 반복해야됨(0~99까지)
# 기본적으로 아래로 진행, 매번 좌우를 살피며 좌 혹은 우에서 1이 있을경우 방향 틀기 방향플래그 변수 필요?
# 해당 방향 플래그 대로 진행하다가 그 방향에서 0이 만나거나 사다리게임 기준 아래에 1이 있을경우
# 즉 항상 교차점일때는 다음이 (0이거나 인덱스 범위 초과하거나) 아래 줄이 1인 경우
# 그렇게 쭉 내려가다가 99줄(마지막 줄) 도착시 종료 종료시 2일 경우 시작 인덱스 출력

import sys
sys.stdin = open('input.txt', 'r')

for t in range(10):
    n = int(input())
    # 100*100 배열생성
    arr = [list(map(int, input().split())) for _ in range(100)]
    for i in range(len(arr)):
        # 맨 윗줄의 값이 1일 경우 시작
        if arr[0][i] == 1:
            # flag 0 = 아래, 1 = 왼, 2 = 오
            flag = 0
            x = 0
            y = i
            while True:
                # 탈출 조건 99도착
                if x == 99:
                    break
                # 아래로 진행 중일 때
                if flag == 0:
                    x += 1
                    # y가 0이 아니고(0이면 왼쪽볼 때 인덱스 에러) 왼쪽을 봤을 때 1이 존재 - 좌측으로 방향틀기
                    if y != 0 and arr[x][y-1] == 1:
                        flag = 1
                    # y가 99가 아니고(y가 99면 오른쪽 한칸 더갈 때 인덱스 에러) 오른쪽을 봤을 때 1이 존재 - 우측으로 틀기
                    elif y != 99 and arr[x][y+1] == 1:
                        flag = 2
                # 왼쪽 진행 중일 때
                elif flag == 1:
                    # 아래를 살펴서 1이면 체인지
                    if y == 0 or arr[x][y-1] == 0:
                        flag = 0
                    # 아니면 왼쪽 그대로 진행
                    else:
                        y -= 1
                # 우측 진행 중 일때
                elif flag == 2:
                    # 아래를 살펴서 1이면 체인지
                    if y == 99 or arr[x][y+1] == 0:
                        flag = 0
                    # 아니면 우측 그대로 진행
                    else:
                        y += 1

            # 이번에 도착한 곳이 2인 도착지 일 경우 더 돌 필요 없으므로 반복 종료
            if arr[x][y] == 2:
                print(f'#{t + 1} {i}')
                break

# 거꾸로 뒤집어서 도착점에서 시작해서 도착하는 출발 인덱스만 구하면 한번만 하면되니까 더 빠르지 않을까?
# 이 문제는 와일문이 조금더 편할까? 조건을 만족하는동안 가므로 와일이 좀더 좋음
